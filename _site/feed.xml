<?xml version="1.0" encoding="UTF-8"?>
<!-- Template from here: https://github.com/diverso/jekyll-rss-feeds -->
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
		<title>Finbarr Timbers</title>
		<description>Personal website for Finbarr Timbers</description>
		<link>http://finbarr.ca</link>
		<atom:link href="http://finbarr.ca/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>GET requests in OCaml</title>
				<description>&lt;p&gt;I&#39;ve been working a lot lately in OCaml, which is a strongly typed, static,
functional language. It is most famously used by &lt;a href=&quot;https://www.janestreet.com/&quot;&gt;Jane Street&lt;/a&gt;, a quantitative trading firm out of New York.
I like OCaml for a number of reasons, but the biggest one is that the language
has very good type inference, as good as Haskell. Consequently, you can write
code that reads like Python, but refactors like C++. I find that I&#39;ll write code
without the type annotations, and then go back and add them once it&#39;s done, which
makes refactoring surprisingly easy.&lt;/p&gt;

&lt;p&gt;One of the most important tasks that the code does is
get updates for the prices of the securities in our portfolio. I do so via a
get request to the &lt;a href=&quot;http://dev.markitondemand.com/&quot;&gt;&lt;code&gt;markitondemand.com&lt;/code&gt;&lt;/a&gt; API.&lt;/p&gt;

&lt;p&gt;I found it shockingly difficult to perform a simple get request in OCaml, so
I&#39;m going to provide a detailed guide on how to do so here, and provide
example code, as well as the commands to compile it.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Download the source from github. In the directory that you want to install the source code into, enter&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; git clone https://github.com/open-source-parsers/jsoncpp
 cd jsoncpp
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create the makefiles. For this step, you must have cmake installed; if it is not installed, you can install it with your system package manager. &lt;a href=&quot;On OS X, I use Homebrew, and on (e.g.) Ubuntu, the package manager is apt-get. On OS X, you would enter `brew install cmake` to install cmake, while on Ubuntu, you would run `apt-get install cmake`.&quot;&gt;1&lt;/a&gt; From jsoncpp/, run&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mkdir -p build/debug
 cd build/debug
 cmake -DCMAKE_BUILD_TYPE=debug -DJSONCPP_LIB_BUILD_SHARED=OFF -G &quot;Unix Makefiles&quot; ../../../jsoncpp
 make
 cd ../..
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enter &lt;code&gt;pwd&lt;/code&gt; and make a note of the output. Now, go to the folder containing the code in which you want to use JSONcpp in. Create a new file called &quot;example.cpp&quot; and enter the following code (taken from Stack Overflow):&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #include &amp;lt;fstream&amp;gt;
 #include &amp;lt;iostream&amp;gt;   
 #include &quot;json/json.h&quot;

 int main() {
     Json::Value root;
     std::ifstream file(&quot;test.json&quot;);
     file &amp;gt;&amp;gt; root;
     std::cout &amp;lt;&amp;lt; root;
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Create another file called &quot;test.json&quot; with the json content you want to read; I used&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {&quot;stocks&quot;: [{&quot;symbol&quot;: &quot;AAPL&quot;,
                 &quot;amount&quot;: 1.03213,
                 &quot;last_price&quot;: 1.20},
                {&quot;symbol&quot;: &quot;MSFT&quot;,
                 &quot;amount&quot;: 2.31039},
                {&quot;symbol&quot;: &quot;F&quot;,
                 &quot;amount&quot;: 0.543589}]}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Compile the code using a &quot;Makefile.&quot; Using your favourite text editor, create a file called &quot;Makefile&quot; and enter the following code (replacing &lt;code&gt;JSONCPPPATH&lt;/code&gt; with the results from running &lt;code&gt;pwd&lt;/code&gt; earlier; mine looks like &lt;code&gt;/Users/ft/Source/jsoncpp/&lt;/code&gt;):&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CXX = g++
 LDFLAGS = -LJSONCPPPATH/build/debug/lib -ljsoncpp
 INC = -IJSONCPPPATH/include

 main: main.cpp
     $(CXX) -o main $(LDFLAGS) $(INC) main.cpp
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;IMPORTANT: you have to indent the &lt;code&gt;$(CXX) -o main...&lt;/code&gt; line with 1 TAB and not 4 SPACES or it won&#39;t work. GNU Make requires a tab for indentation.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Now, compile the code by running &lt;code&gt;make main&lt;/code&gt;. You should now be able to run the code by entering &lt;code&gt;./main&lt;/code&gt;. It will print the contents of your &lt;code&gt;test.json&lt;/code&gt; file to your terminal.&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Fri, 10 Oct 2014 00:00:00 -0600</pubDate>
				<link>http://finbarr.ca/GET-requests-ocaml/</link>
				<guid isPermaLink="true">http://finbarr.ca/GET-requests-ocaml/</guid>
			</item>
		
			<item>
				<title>Full example for using JSONcpp on Unix</title>
				<description>&lt;p&gt;I&#39;ve been trying to parse JSON files with C++, and I&#39;ve found a distinct lack of
full examples on how to do so. Specifically, I&#39;ve struggled to find the proper
commands to actually compile the code. For future reference (and to help any
beginners out), here&#39;s a full example of how to use &lt;a href=&quot;https://github.com/open-source-parsers/jsoncpp&quot; title=&quot;JSONcpp on github&quot;&gt;JSONcpp&lt;/a&gt; in your code (N.B. You&#39;re supposed to enter all of the following code in your terminal).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Download the source from github. In the directory that you want to install the source code into, enter&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; git clone https://github.com/open-source-parsers/jsoncpp
 cd jsoncpp
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create the makefiles. For this step, you must have cmake installed; if it is not installed, you can install it with your system package manager. &lt;a href=&quot;On OS X, I use Homebrew, and on (e.g.) Ubuntu, the package manager is apt-get. On OS X, you would enter `brew install cmake` to install cmake, while on Ubuntu, you would run `apt-get install cmake`.&quot;&gt;1&lt;/a&gt; From jsoncpp/, run&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mkdir -p build/debug
 cd build/debug
 cmake -DCMAKE_BUILD_TYPE=debug -DJSONCPP_LIB_BUILD_SHARED=OFF -G &quot;Unix Makefiles&quot; ../../../jsoncpp
 make
 cd ../..
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enter &lt;code&gt;pwd&lt;/code&gt; and make a note of the output. Now, go to the folder containing the code in which you want to use JSONcpp in. Create a new file called &quot;example.cpp&quot; and enter the following code (taken from Stack Overflow):&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; #include &amp;lt;fstream&amp;gt;
 #include &amp;lt;iostream&amp;gt;

 #include &quot;json/json.h&quot;

 int main() {
     Json::Value root;
     std::ifstream file(&quot;test.json&quot;);
     file &amp;gt;&amp;gt; root;
     std::cout &amp;lt;&amp;lt; root;
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;Create another file called &quot;test.json&quot; with the json content you want to read; I used&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;stocks&quot;: [
         {&quot;symbol&quot;: &quot;AAPL&quot;,
          &quot;amount&quot;: 1.03213,
          &quot;last_price&quot;: 1.20},
         {&quot;symbol&quot;: &quot;MSFT&quot;,
          &quot;amount&quot;: 2.31039},
         {&quot;symbol&quot;: &quot;F&quot;,
          &quot;amount&quot;: 0.543589}
          ]
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Compile the code using a &quot;Makefile.&quot; Using your favourite text editor, create a file called &quot;Makefile&quot; and enter the following code (replacing &lt;code&gt;JSONCPPPATH&lt;/code&gt; with the results from running &lt;code&gt;pwd&lt;/code&gt; earlier; mine looks like &lt;code&gt;/Users/ft/Source/jsoncpp/&lt;/code&gt;):&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CXX = g++
 LDFLAGS = -LJSONCPPPATH/build/debug/lib -ljsoncpp
 INC = -IJSONCPPPATH/include

 main: main.cpp
     $(CXX) -o main $(LDFLAGS) $(INC) main.cpp
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;IMPORTANT: you have to indent the &lt;code&gt;$(CXX) -o main...&lt;/code&gt; line with 1 TAB and not 4 SPACES or it won&#39;t work. GNU Make requires a tab for indentation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now, compile the code by running &lt;code&gt;make main&lt;/code&gt;. You should now be able to run the code by entering &lt;code&gt;./main&lt;/code&gt;. It will print the contents of your &lt;code&gt;test.json&lt;/code&gt; file to your terminal.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Sat, 06 Sep 2014 00:00:00 -0600</pubDate>
				<link>http://finbarr.ca/jsoncpp-example/</link>
				<guid isPermaLink="true">http://finbarr.ca/jsoncpp-example/</guid>
			</item>
		
			<item>
				<title>ARIMA, ARMA, what's the difference?</title>
				<description>&lt;p&gt;I&#39;m working through &lt;a href=&quot;[1]&quot;&gt;TSA&lt;/a&gt;, and I noticed that some of my classmates are struggling to understand the difference between an ARIMA process, an AR process, and a MA process, not to mention seasonal version of the above.&lt;/p&gt;

&lt;p&gt;Using &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; as the lag operator, i.e. &lt;script type=&quot;math/tex&quot;&gt;BX_t = X_{t-1}&lt;/script&gt;, an &lt;em&gt;ARIMA(p, d, q) process&lt;/em&gt; is a discrete time stochastic process of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\phi(B) (1 - B)^d X_t = \theta(B)w_t,&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\phi&lt;/script&gt; is a polynomial of degree &lt;em&gt;p&lt;/em&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt; is a polynomial of degree &lt;em&gt;q&lt;/em&gt;. An &lt;em&gt;AR(p)&lt;/em&gt; process is an ARIMA(&lt;em&gt;p, 0, 0&lt;/em&gt;) process, and a MA(&lt;em&gt;q&lt;/em&gt;) process is an ARIMA(&lt;em&gt;0, 0, q&lt;/em&gt;) process. To make life even more complicated, we introduce the notion of seasonality:&lt;/p&gt;

&lt;p&gt;An ARIMA&lt;script type=&quot;math/tex&quot;&gt;(p, d, q) \times (P, D, Q)_s&lt;/script&gt; model is a s.p. of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Phi(B^s) \phi(B) (1 - B^s)^D (1 - B)^d X_t = \Theta(B^s)\theta(B)w_t,&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\Phi(B)&lt;/script&gt; is a polynomial of degree &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\Theta(B)&lt;/script&gt; is a polynomial of degree &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;

&lt;p&gt;Suppose we have the stochastic process&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X_t = \frac 1 2 X_{t-1} + X_{t-4} - \frac 1 2 X_{t-5} + w_t - \frac 1 4 w_{t-4}.&lt;/script&gt;

&lt;p&gt;How can we write this as an ARIMA&lt;script type=&quot;math/tex&quot;&gt;(p, d, q) \times (P, D, Q)_s&lt;/script&gt; model? Note that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(1 - B^4) X_t = \frac 1 2 X_{t-1} - \frac 1 2 X_{t-5} + w_t - \frac 1 4 w_{t-4}.&lt;/script&gt;

&lt;p&gt;We can rewrite this as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(1 - B^4) X_t - \frac{1}{2} B (1 - B^4)X_t = (1 - \frac 1 4 B^4) w_t,&lt;/script&gt;

&lt;p&gt;or, more concisely,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(1 - B^4) (1 - \frac 1 2 B) X_t = (1 - \frac 1 4 B^4) w_t.&lt;/script&gt;

&lt;p&gt;Consequently, we can see that &lt;script type=&quot;math/tex&quot;&gt;X_t&lt;/script&gt; is an ARIMA&lt;script type=&quot;math/tex&quot;&gt;(1, 0, 0) \times (0, 1, 1)_4&lt;/script&gt; process.&lt;/p&gt;

</description>
				<pubDate>Mon, 21 Apr 2014 00:00:00 -0600</pubDate>
				<link>http://finbarr.ca/arima-arma-what/</link>
				<guid isPermaLink="true">http://finbarr.ca/arima-arma-what/</guid>
			</item>
		
			<item>
				<title>Solving Pacf</title>
				<description>&lt;p&gt;I&#39;ve been studying time series through &lt;a href=&quot;http://www.stat.pitt.edu/stoffer/tsa3/&quot;&gt;TSA&lt;/a&gt;. The book presents a structured
approach to time series analysis, and covers the material fairly well; I was
impressed with the description of what a partial autocorrelation function (PACF)
is, as the book explained it more intuitively than the lecture notes did. I did
find the description of how to actually solve for the PACF a bit confusing, so I
wrote my own explanation.&lt;/p&gt;

&lt;h2 id=&quot;partial-autocorrelation-functions&quot;&gt;Partial Autocorrelation Functions&lt;/h2&gt;

&lt;p&gt;What are PACFs, and why would one want to use one? As explained in TSA, the PACF
is useful as it provides an analog to the autocorrelation function, or ACF, but
for autoregressive processes. The ACF is particularly useful as for an &lt;script type=&quot;math/tex&quot;&gt;MA(q)&lt;/script&gt;, the autocorrelation function &lt;script type=&quot;math/tex&quot;&gt;\gamma(m)&lt;/script&gt; has the nice property that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align*} \gamma(m) = 0 \text{ for } m &gt; q.  \end{align*}&lt;/script&gt;

&lt;p&gt;Consequently, by plotting the ACF (as can be done
&lt;a href=&quot;http://bl.ocks.org/timbers/9318155&quot;&gt;easily&lt;/a&gt; in R), we can detect the order of
the &lt;script type=&quot;math/tex&quot;&gt;MA(q)&lt;/script&gt; process.&lt;/p&gt;

&lt;p&gt;The property fails for the ACF of an &lt;script type=&quot;math/tex&quot;&gt;AR(p)&lt;/script&gt; process. However, the PACF is
here to step in and save the day. With the PACF defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align*} \phi_{mm} := \alpha^{\star}_{m, m}, \end{align*}&lt;/script&gt;

&lt;p&gt;where the &lt;script type=&quot;math/tex&quot;&gt;\alpha^{\star}_{j, k}&lt;/script&gt; are defined as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align*} \alpha_{1, m}, \cdots, \alpha_{m, m} = \text{argmin} E(X_{t} -
\alpha_{1, m} X_{t-1} - \cdots - \alpha_{m, m} X_{t-m})^2.  \end{align*}&lt;/script&gt;

&lt;p&gt;Then, the PACF exhibits the property that for an &lt;script type=&quot;math/tex&quot;&gt;AR(p)&lt;/script&gt; process, &lt;script type=&quot;math/tex&quot;&gt;\phi_{pp} = \phi_{p}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\phi_{mm} = 0&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;m &gt; p&lt;/script&gt;; consequently, by
calculating the PACF of a process, we can easily detect the order of it if it is
autoregressive.&lt;/p&gt;

&lt;h2 id=&quot;example-1&quot;&gt;Example 1&lt;/h2&gt;

&lt;p&gt;Suppose we have the process&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align*} X_{t} = \phi_1 X_{t-1} + \phi_2 X_{t-2} + w_t, \end{align*}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;w_t&lt;/script&gt; is a sequence of uncorrelated variables with zero mean and
constant variance. What is the PACF for this process? As the AR polynomial &lt;script type=&quot;math/tex&quot;&gt;\phi(B)&lt;/script&gt; has no roots with &lt;script type=&quot;math/tex&quot;&gt;|B| \leq 1,&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;X_{t}&lt;/script&gt; is a weakly stationary
process; consequently, we know that &lt;script type=&quot;math/tex&quot;&gt;\phi_{22} = \phi_2, \phi_{mm} = 0&lt;/script&gt; for
&lt;script type=&quot;math/tex&quot;&gt;m &gt; p&lt;/script&gt;. Consequently, we only need to figure out &lt;script type=&quot;math/tex&quot;&gt;\phi_{11}&lt;/script&gt;. To find it,
we must solve&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align*} \text{argmin} E(X_{t} - \phi_{11} X_{t-1})^2\\ \end{align*}&lt;/script&gt;

&lt;p&gt;To do so, we take the derivative with respect to &lt;script type=&quot;math/tex&quot;&gt;\phi_{11}&lt;/script&gt; and set it
equal to zero:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*} &amp;E[-2X_{t-1}(X_{t} - \phi_{11} X_{t-1})] = 0 \\ \iff &amp;-2
\gamma(1) + 2 \phi_{11} \gamma(0) = 0 \\ \iff &amp; \phi_{11} = \rho(1) \end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;Now, we need to solve for &lt;script type=&quot;math/tex&quot;&gt;\rho&lt;/script&gt; in terms of &lt;script type=&quot;math/tex&quot;&gt;\phi_{1}, \phi_{2}&lt;/script&gt;. To do
this, we exploit the Yule-Walker equations:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*} \gamma(1) - \phi_{1} \gamma(0) - \phi_{2} \gamma(1) &amp;= 0\\
\rho(1) &amp;= \phi_{1} + \phi_{2} \rho(1) \\ \longrightarrow \phi_{11} = \rho(1) &amp;=
\frac{ \phi_{1} }{ 1 - \phi_{2} } \end{align*} %]]&gt;&lt;/script&gt;

</description>
				<pubDate>Mon, 03 Mar 2014 00:00:00 -0700</pubDate>
				<link>http://finbarr.ca/solving-pacf/</link>
				<guid isPermaLink="true">http://finbarr.ca/solving-pacf/</guid>
			</item>
		
	</channel>
</rss>
